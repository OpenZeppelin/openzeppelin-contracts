= Account Abstraction

Unlike Externally Owned Accounts (EOAs), smart contracts may contain arbitrary verification logic based on authentication mechanisms different to Ethereum's native xref:api:utils.adoc#ECDSA[ECDSA] and have execution advantages such as batching or gas sponsorship. To leverage these properties of smart contracts, the community has widely adopted https://eips.ethereum.org/EIPS/eip-4337[ERC-4337], a standard to process user operations through an alternative mempool.

OpenZeppelin Contracts provides multiple contracts for Account Abstraction following this standard as it enables more flexible and user-friendly interactions with applications. Account Abstraction use cases include wallets in novel contexts (e.g. embedded wallets), more granular configuration of accounts, recovery mechanisms and modularity with standards such as xref:erc7579.adoc#ERC7579[ERC-7579].

== ERC-4337 Overview

The ERC-4337 is a detailed specification of how to implement the necessary logic to handle operations without making changes to the protocol level (i.e. the rules of the blockchain itself). This specification defines the following components:

=== UserOperation

An `UserOperation` is a higher-layer pseudo-transaction object that represents the intent of the account. This shares some similarities with regular EVM transactions like the concept of `gasFees` or `callData` but includes fields that enable new capabilities.

```solidity
struct PackedUserOperation {
    address sender;
    uint256 nonce;
    bytes initCode; // concatenation of factory address and factoryData (or empty)
    bytes callData;
    bytes32 accountGasLimits; // concatenation of verificationGas (16 bytes) and callGas (16 bytes)
    uint256 preVerificationGas;
    bytes32 gasFees; // concatenation of maxPriorityFee (16 bytes) and maxFeePerGas (16 bytes)
    bytes paymasterAndData; // concatenation of paymaster fields (or empty)
    bytes signature;
}
```

=== Entrypoint

Each `UserOperation` is executed through a contract known as the https://etherscan.io/address/0x0000000071727de22e5e9d8baf0edac6f37da032#code[`EntryPoint`]. This contract is a singleton deployed across multiple networks at the same address although other custom implementations may be used.

The Entrypoint contracts is considered a trusted entity by the account.

=== Bundlers

The bundler is a piece of _offchain_ infrastructure that is in charge of processing an alternative mempool of user operations. Bundlers themselves call the Entrypoint contract's `handleOps` function with an array of UserOperations that are executed and included in a block.

During the process, the bundler pays for the gas of executing the transaction and gets refunded during the execution phase of the Entrypoint contract.

=== Account Contract

The Account Contract is the implementation logic (i.e. Solidity code) that validates user operations and is defined by the Account developer. 

NOTE: To build your own account, see xref:account-abstraction.adoc#smart_accounts[Smart Accounts].

=== Factory Contract

The smart contract accounts are created by a Factory contract defined by the Account developer. This factory receives arbitrary bytes as `initData` and returns an `address` where the logic of the account is deployed.

NOTE: To build your own factory, see xref:account-abstraction.adoc#account_factory[Account Factory]

=== Paymaster Contract

A Paymaster is an optional entity that can sponsor gas fees for Accounts, or allow them to pay for those fees in ERC-20 instead of native currency. This abstracts gas away of the user experience in the same way that computational costs of cloud servers are abstracted away from end-users.

NOTE: To build your own factory, see xref:account-abstraction.adoc#paymaster[Paymaster].

== Smart Accounts

A Smart Account (or simply xref:api:account.adoc[`Account`]) is a type of smart contract implements the logic required to validate an `UserOperation` in the context of ERC-4337. Any smart contract account should conform with the `IAccount` interface to validate operations.

```solidity
interface IAccount {
    function validateUserOp(PackedUserOperation calldata, bytes32, uint256) external returns (uint256 validationData);
}
```

Similarly, an Account should have a way to execute these operations by either handling arbitrary calldata on its `fallback` or implementing the `IAccountExecute` interface:

```solidity
interface IAccountExecute {
    function executeUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash) external;
}
```

OpenZeppelin provides an implementation of an xref:api:account.adoc#AccountBase[`AccountBase`] that implements both interfaces and accepts native currency and common tokens (i.e. xref:erc20.adoc[ERC-20], xref:erc721.adoc[ERC-721] and xref:erc1155.adoc[ERC-1155]), as well as executing any arbitrary `UserOperation`.

=== Signers

Generally speaking, blockchains use the properties of https://en.wikipedia.org/wiki/Digital_signature[digital signatures] to authenticate the sender of each transaction. With this in mind, developers can xref:utilities.adoc#checking_signatures_on_chain[verify signatures on-chain] as a way to authenticate user operations for a given off-chain signer (i.e. a private key).

In this context, a Signer is a contract that stores the public key corresponding to an off-chain private key that works with a custom digital signature verification algorithm. Each signer stores the public key in immutable arguments for better signature interoperability.

A Signer account can be extended as follows:

```solidity
// contracts/MyAccountECDSA.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {AccountSignerECDSA} from "@openzeppelin/contracts/account/signers/AccountSignerECDSA.sol";
import {EIP712} from "../../utils/cryptography/EIP712.sol";

contract MyAccountECDSA is AccountSignerECDSA {
    constructor(
        address signerAddr,
        string memory name,
        string memory version
    ) AccountSignerECDSA(signerAddr) EIP712(name, version) {}

    /// ...
}
```

IMPORTANT: Accounts must be deployed via an xref:api:account.adoc#AccountFactory[`AccountFactory`] instead of deployed directly.

==== ERC-7562 Validation Rules

A naive approach to implement an Account contract with a signer would be to store its public key in the account's storage for future validation and, ideally, would expose the xref:api:interfaces::IERC1271[`IERC1271`] interface (smart contract signatures) to act as a validator in more complex setups (e.g. a multisignature). 

However, the validation phase of ERC-4337 forbids access to external storage according to the https://eips.ethereum.org/EIPS/eip-7562[ERC-7562] validation rules. Unfortunately, this rules limit the interoperability of signers unless the public key is stored somewhere other than storage.

For this reason, the Signer contracts store the public key for its corresponding validation algorithm in immutable arguments so that the contract is tied to the signer and can validate messages on-chain without accessing storage.

==== Readable Typed Signatures

A common security practice to prevent user operation https://mirror.xyz/curiousapple.eth/pFqAdW2LiJ-6S4sg_u1z08k4vK6BCJ33LcyXpnNb8yU[replayability across smart contract accounts controlled by the same private key] (i.e. multiple accounts for the same signer) is to link the signature to the `address` and `chainId`. This can be done by asking the user to sign the hash of the user operation along with this values.

The problem with this approach is that the user might be prompted by the wallet provider to sign an https://x.com/howydev/status/1780353754333634738[obfuscated message], which is a phishing vector that may lead to a user losing its assets.

To prevent this, each smart contract signer inherits from xref:api:account#EIP712Signer[`EIP712Signer`], a utility that implements a defensive rehashing mechanism based on a https://github.com/frangio/eip712-wrapper-for-eip1271[nested EIP-712 approach] to wrap the signature request in a context where there's clearer information for the end user.

=== Modules

Modules are a way to extend functionality of an smart account. Given the variety of smart account implementations, a common approach has been to enable a system of modules to which accounts can delegate logic. As a result, the community has proposed xref:erc7579.adoc#ERC7579[ERC-7579] as a minimal generalized approach to smart account modules.

OpenZeppelin's xref:api:account.adoc#ERC7579Account[`ERC7579Account`] is an ERC-7579 compliant implementation that works without a signer, and instead, requires a validator module to be enabled on the account. This validator module might be any

== Account Factory

Accounts are deployed using an xref:api:account.adoc#AccountFactory[`AccountFactory`] contract, a special contract that creates new accounts during the validation phase of the EntryPoint.

The factory works by creating xref:api:proxy.adoc#Clones-cloneDeterministicWithImmutableArgs-address-bytes-bytes32-[minimal clones with immutable arguments] which write the arguments in the bytecode of each deployed proxy. In most cases, the immutable arguments would be the public key of the associated signer and will need adjustments to fetch it.

=== Clonable Accounts

When used with an xref:api:account.adoc#AccountFactory[`AccountFactory`], the Account Signer contracts expose a variant suffixed with `*Clonable` that may be used to generate clones of an account with arbitrary immutable arguments.

```solidity
// contracts/MyAccountClonable.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {
  AccountSignerECDSA, // Original
  AccountSignerECDSAClonable // Adapted for minimal clones with immutable arguments
} from "@openzeppelin/contracts/account/signers/AccountSignerECDSA.sol";

contract MyAccountClonableImplementation is AccountSignerECDSAClonable {
    // Arguments don't matter on the implementation.
    constructor() AccountSignerECDSAClonable(address(0), "", "") {}
}
```

=== Setting up a factory

To setup a factory, all you need is a xref:account-abstraction.adoc#clonable_accounts[Clonable Account] and implement the `clone` function of the xref:api:account.adoc#AccountFactory[`AccountFactory`] contract

```solidity
// contracts/MyAccountFactory.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {AccountFactory} from "@openzeppelin/contracts/account/AccountFactory.sol";
import {MyAccountClonableImplementation} from "./MyAccountClonableImplementation.sol";

contract MyAccountFactory is AccountFactory {
    constructor() AccountFactory(address(new MyAccountClonableImplementation())) {}

    function clone(bytes memory encodedSigner, bytes32 salt) external override returns (address) {
        return _clone(encodedSigner, salt);
    }
}
```

== Paymaster
