// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Bytecode} from "./Bytecode.sol";

/**
 * @dev Library for storing and retrieving data using contract bytecode storage (SSTORE2 pattern).
 *
 * This library provides a more gas-efficient alternative to traditional storage for large data
 * by storing data as contract bytecode. The data is stored by deploying a contract with the data
 * as its bytecode, and retrieved by reading that bytecode back.
 *
 * NOTE: The stored data cannot be modified after deployment. Each write creates a new contract.
 *
 * Based on SSTORE2 by Agustin Aguilar: https://github.com/0xsequence/sstore2
 */
library SSTORE2 {
    /**
     * @dev Error thrown when contract deployment fails during write operation.
     */
    error WriteError();

    /**
     * @dev Stores `data` and returns `pointer` as key for later retrieval.
     *
     * The pointer is a contract address with `data` as code. A 0x00 byte is prepended
     * to the data to prevent the deployed contract from being callable.
     *
     * @param data Data to be written
     * @return pointer Pointer to the written `data`
     */
    function write(bytes memory data) internal returns (address pointer) {
        // Append 00 to data so contract can't be called
        // Build init code
        bytes memory code = Bytecode.creationCodeFor(abi.encodePacked(hex"00", data));

        // Deploy contract using create
        assembly {
            pointer := create(0, add(code, 32), mload(code))
        }

        // Address MUST be non-zero
        if (pointer == address(0)) revert WriteError();
    }

    /**
     * @dev Reads the contents of the `pointer` code as data, skips the first byte.
     *
     * The function is intended for reading pointers generated by {write}.
     *
     * @param pointer Pointer to be read
     * @return data Data read from `pointer` contract
     */
    function read(address pointer) internal view returns (bytes memory) {
        return Bytecode.codeAt(pointer, 1, type(uint256).max);
    }

    /**
     * @dev Reads the contents of the `pointer` code as data, skips the first byte.
     *
     * The function is intended for reading pointers generated by {write}.
     *
     * @param pointer Pointer to be read
     * @param start Number of bytes to skip (in addition to the first byte)
     * @return data Data read from `pointer` contract
     */
    function read(address pointer, uint256 start) internal view returns (bytes memory) {
        return Bytecode.codeAt(pointer, start + 1, type(uint256).max);
    }

    /**
     * @dev Reads the contents of the `pointer` code as data, skips the first byte.
     *
     * The function is intended for reading pointers generated by {write}.
     *
     * @param pointer Pointer to be read
     * @param start Number of bytes to skip (in addition to the first byte)
     * @param end Index before which to end extraction (in addition to the first byte)
     * @return data Data read from `pointer` contract
     */
    function read(address pointer, uint256 start, uint256 end) internal view returns (bytes memory) {
        return Bytecode.codeAt(pointer, start + 1, end + 1);
    }
}
