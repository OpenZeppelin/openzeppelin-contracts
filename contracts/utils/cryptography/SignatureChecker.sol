// SPDX-License-Identifier: MIT
// OpenZeppelin Contracts (last updated v5.5.0) (utils/cryptography/SignatureChecker.sol)

pragma solidity ^0.8.24;

import {ECDSA} from "./ECDSA.sol";
import {IERC1271} from "../../interfaces/IERC1271.sol";
import {IERC7913SignatureVerifier} from "../../interfaces/IERC7913.sol";
import {Bytes} from "../Bytes.sol";
import {LowLevelCall} from "../LowLevelCall.sol";
import {RelayedCall} from "../RelayedCall.sol";
import {Calldata} from "../Calldata.sol";

/**
 * @dev Signature verification helper that can be used instead of `ECDSA.recover` to seamlessly support:
 *
 * * ECDSA signatures from externally owned accounts (EOAs)
 * * ERC-1271 signatures from smart contract wallets like Argent and Safe Wallet (previously Gnosis Safe)
 * * ERC-6492 signatures from smart contracts that have not been deployed yet
 * * ERC-7913 signatures from keys that do not have an Ethereum address of their own
 *
 * See https://eips.ethereum.org/EIPS/eip-1271[ERC-1271], https://eips.ethereum.org/EIPS/eip-6492[ERC-6492],
 * and https://eips.ethereum.org/EIPS/eip-7913[ERC-7913].
 */
library SignatureChecker {
    using Bytes for bytes;

    bytes32 private constant ERC6492_SUFFIX = 0x6492649264926492649264926492649264926492649264926492649264926492;

    /**
     * @dev Checks if a signature is valid for a given signer and data hash. If the signer has code, the
     * signature is validated against it using ERC-1271, otherwise it's validated using `ECDSA.recover`.
     *
     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus
     * change through time. It could return true at block N and false at block N+1 (or the opposite).
     *
     * NOTE: For ERC-6492 signature validation (signatures from contracts that have not been deployed yet),
     * see {isValidERC6492SignatureNow}.
     *
     * NOTE: For an extended version of this function that supports ERC-7913 signatures, see {isValidSignatureNow-bytes-bytes32-bytes-}.
     */
    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {
        if (signer.code.length == 0) {
            (address recovered, ECDSA.RecoverError err, ) = ECDSA.tryRecover(hash, signature);
            return err == ECDSA.RecoverError.NoError && recovered == signer;
        } else {
            return isValidERC1271SignatureNow(signer, hash, signature);
        }
    }

    /**
     * @dev Variant of {isValidSignatureNow} that takes a signature in calldata
     */
    function isValidSignatureNowCalldata(
        address signer,
        bytes32 hash,
        bytes calldata signature
    ) internal view returns (bool) {
        if (signer.code.length == 0) {
            (address recovered, ECDSA.RecoverError err, ) = ECDSA.tryRecoverCalldata(hash, signature);
            return err == ECDSA.RecoverError.NoError && recovered == signer;
        } else {
            return isValidERC1271SignatureNowCalldata(signer, hash, signature);
        }
    }

    /**
     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated
     * against the signer smart contract using ERC-1271.
     *
     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus
     * change through time. It could return true at block N and false at block N+1 (or the opposite).
     */
    function isValidERC1271SignatureNow(
        address signer,
        bytes32 hash,
        bytes memory signature
    ) internal view returns (bool result) {
        bytes4 selector = IERC1271.isValidSignature.selector;
        uint256 length = signature.length;

        assembly ("memory-safe") {
            // Encoded calldata is :
            // [ 0x00 - 0x03 ] <selector>
            // [ 0x04 - 0x23 ] <hash>
            // [ 0x24 - 0x43 ] <signature offset> (0x40)
            // [ 0x44 - 0x63 ] <signature length>
            // [ 0x64 - ...  ] <signature data>
            let ptr := mload(0x40)
            mstore(ptr, selector)
            mstore(add(ptr, 0x04), hash)
            mstore(add(ptr, 0x24), 0x40)
            mcopy(add(ptr, 0x44), signature, add(length, 0x20))

            let success := staticcall(gas(), signer, ptr, add(length, 0x64), 0x00, 0x20)
            result := and(success, and(gt(returndatasize(), 0x1f), eq(mload(0x00), selector)))
        }
    }

    function isValidERC1271SignatureNowCalldata(
        address signer,
        bytes32 hash,
        bytes calldata signature
    ) internal view returns (bool result) {
        bytes4 selector = IERC1271.isValidSignature.selector;
        uint256 length = signature.length;

        assembly ("memory-safe") {
            // Encoded calldata is :
            // [ 0x00 - 0x03 ] <selector>
            // [ 0x04 - 0x23 ] <hash>
            // [ 0x24 - 0x43 ] <signature offset> (0x40)
            // [ 0x44 - 0x63 ] <signature length>
            // [ 0x64 - ...  ] <signature data>
            let ptr := mload(0x40)
            mstore(ptr, selector)
            mstore(add(ptr, 0x04), hash)
            mstore(add(ptr, 0x24), 0x40)
            mstore(add(ptr, 0x44), length)
            calldatacopy(add(ptr, 0x64), signature.offset, length)

            let success := staticcall(gas(), signer, ptr, add(length, 0x64), 0x00, 0x20)
            result := and(success, and(gt(returndatasize(), 0x1f), eq(mload(0x00), selector)))
        }
    }

    function isValidERC6492SignatureNow(address signer, bytes32 hash, bytes memory signature) internal returns (bool) {
        bool hasCode = signer.code.length > 0;
        bytes32 suffix;
        assembly ("memory-safe") {
            // Extracts the suffix word without allocating extra memory
            suffix := mload(add(signature, mload(signature)))
        }
        bool isValid;

        // Behaves as a switch statement
        while (true) {
            // Case 1: Standard ERC-1271 signature validation
            if (suffix != ERC6492_SUFFIX) {
                if (hasCode) isValid = isValidERC1271SignatureNow(signer, hash, signature);
                break;
            }

            // Case 2: ERC-6492 signature validation with a contract already deployed
            // Assumes the signature is always encoded as (factoryOrPrepareTo, factoryOrPrepareCalldata, signature, suffix)
            // since the contract might had been deployed before the signature was submitted.
            bool decodable;
            address factoryOrPrepareTo;
            bytes memory factoryOrPrepareCalldata;
            (decodable, factoryOrPrepareTo, factoryOrPrepareCalldata, signature) = _tryDecodeERC6492Signature(
                signature.splice(0, signature.length - 32) // Remove the suffix
            );
            if (!decodable) return false; // Suffixed. Can't decode. Just return false.
            if (hasCode) {
                isValid = isValidERC1271SignatureNow(signer, hash, signature);
                if (isValid) break;
            }

            // Case 3: ERC-6492 signature validation with a contract not yet deployed or preparation failed
            // Either has no code or the signature was invalid. We need to try to deploy/prepare the contract.

            // Use a dedicated relayer for ERC-6492 signatures so that the caller
            // can't be arbitrarily used if it has special permissions on a target contract
            (bool success, ) = RelayedCall.relayRevertingCall(
                factoryOrPrepareTo,
                factoryOrPrepareCalldata,
                ERC6492_SUFFIX
            );
            isValid = success && isValidERC1271SignatureNow(signer, hash, signature); // Short-circuit validation if the call failed
            break;
        }

        // Fallback to ECDSA signature validation
        if (!hasCode && !isValid) {
            (address recovered, ECDSA.RecoverError err, ) = ECDSA.tryRecover(hash, signature);
            isValid = err == ECDSA.RecoverError.NoError && recovered == signer;
        }

        return isValid;
    }

    function isValidERC6492SignatureNowCalldata(
        address signer,
        bytes32 hash,
        bytes calldata signature
    ) internal returns (bool) {
        bool hasCode = signer.code.length > 0;
        bytes32 suffix = bytes32(signature[signature.length - 32:]);
        bool isValid;

        // Behaves as a switch statement
        while (true) {
            // Case 1: Standard ERC-1271 signature validation
            if (suffix != ERC6492_SUFFIX) {
                if (hasCode) isValid = isValidERC1271SignatureNowCalldata(signer, hash, signature);
                break;
            }

            // Case 2: ERC-6492 signature validation with a contract already deployed
            // Assumes the signature is always encoded as (factoryOrPrepareTo, factoryOrPrepareCalldata, signature, suffix)
            // since the contract might had been deployed before the signature was submitted.
            bool decodable;
            address factoryOrPrepareTo;
            bytes calldata factoryOrPrepareCalldata;
            (decodable, factoryOrPrepareTo, factoryOrPrepareCalldata, signature) = _tryDecodeERC6492SignatureCalldata(
                signature[0:signature.length - 32] // Avoid the suffix
            );
            if (!decodable) return false; // Suffixed. Can't decode. Just return false.
            if (hasCode) {
                isValid = isValidERC1271SignatureNow(signer, hash, signature);
                if (isValid) break;
            }

            // Case 3: ERC-6492 signature validation with a contract not yet deployed or preparation failed
            // Either has no code or the signature was invalid. We need to try to deploy/prepare the contract.

            // Use a dedicated relayer for ERC-6492 signatures so that the caller
            // can't be arbitrarily used if it has special permissions on a target contract
            (bool success, ) = RelayedCall.relayRevertingCall(
                factoryOrPrepareTo,
                factoryOrPrepareCalldata,
                ERC6492_SUFFIX
            );
            isValid = success && isValidERC1271SignatureNow(signer, hash, signature); // Short-circuit validation if the call failed
            break;
        }

        // Fallback to ECDSA signature validation
        if (!hasCode && !isValid) {
            (address recovered, ECDSA.RecoverError err, ) = ECDSA.tryRecover(hash, signature);
            isValid = err == ECDSA.RecoverError.NoError && recovered == signer;
        }

        return isValid;
    }

    function isValidERC6492SignatureNowAllowSideEffects(
        address signer,
        bytes32 hash,
        bytes memory signature
    ) internal returns (bool) {
        bool hasCode = signer.code.length > 0;
        bytes32 suffix;
        assembly ("memory-safe") {
            // Extracts the suffix word without allocating extra memory
            suffix := mload(add(signature, mload(signature)))
        }
        bool isValid;

        // Behaves as a switch statement
        while (true) {
            // Case 1: Standard ERC-1271 signature validation
            if (suffix != ERC6492_SUFFIX) {
                if (hasCode) isValid = isValidERC1271SignatureNow(signer, hash, signature);
                break;
            }

            // Case 2: ERC-6492 signature validation with a contract already deployed
            // Assumes the signature is always encoded as (factoryOrPrepareTo, factoryOrPrepareCalldata, signature, suffix)
            // since the contract might had been deployed before the signature was submitted.
            bool decodable;
            address factoryOrPrepareTo;
            bytes memory factoryOrPrepareCalldata;
            (decodable, factoryOrPrepareTo, factoryOrPrepareCalldata, signature) = _tryDecodeERC6492Signature(
                signature.splice(0, signature.length - 32) // Remove the suffix
            );
            if (!decodable) return false; // Suffixed. Can't decode. Just return false.
            if (hasCode) {
                isValid = isValidERC1271SignatureNow(signer, hash, signature);
                if (isValid) break;
            }

            // Case 3: ERC-6492 signature validation with a contract not yet deployed or preparation failed
            // Either has no code or the signature was invalid. We need to try to deploy/prepare the contract.
            if (
                LowLevelCall.callNoReturn(
                    // Use a dedicated relayer for ERC-6492 signatures so that the caller
                    // can't be arbitrarily used if it has special permissions on a target contract
                    RelayedCall.getRelayer(ERC6492_SUFFIX),
                    abi.encodePacked(factoryOrPrepareTo, factoryOrPrepareCalldata)
                )
            ) {
                isValid = isValidERC1271SignatureNow(signer, hash, signature);
            } // Do not attempt validation if the call failed
            break;
        }

        // Fallback to ECDSA signature validation
        if (!hasCode && !isValid) {
            (address recovered, ECDSA.RecoverError err, ) = ECDSA.tryRecover(hash, signature);
            isValid = err == ECDSA.RecoverError.NoError && recovered == signer;
        }

        return isValid;
    }

    function isValidERC6492SignatureNowAllowSideEffectsCalldata(
        address signer,
        bytes32 hash,
        bytes calldata signature
    ) internal returns (bool) {
        bool hasCode = signer.code.length > 0;
        bytes32 suffix = bytes32(signature[signature.length - 32:]);
        bool isValid;

        // Behaves as a switch statement
        while (true) {
            // Case 1: Standard ERC-1271 signature validation
            if (suffix != ERC6492_SUFFIX) {
                if (hasCode) isValid = isValidERC1271SignatureNowCalldata(signer, hash, signature);
                break;
            }

            // Case 2: ERC-6492 signature validation with a contract already deployed
            // Assumes the signature is always encoded as (factoryOrPrepareTo, factoryOrPrepareCalldata, signature, suffix)
            // since the contract might had been deployed before the signature was submitted.
            bool decodable;
            address factoryOrPrepareTo;
            bytes calldata factoryOrPrepareCalldata;
            (decodable, factoryOrPrepareTo, factoryOrPrepareCalldata, signature) = _tryDecodeERC6492SignatureCalldata(
                signature[0:signature.length - 32] // Avoid the suffix
            );
            if (!decodable) return false; // Suffixed. Can't decode. Just return false.
            if (hasCode) {
                isValid = isValidERC1271SignatureNow(signer, hash, signature);
                if (isValid) break;
            }

            // Case 3: ERC-6492 signature validation with a contract not yet deployed or preparation failed
            // Either has no code or the signature was invalid. We need to try to deploy/prepare the contract.
            if (
                LowLevelCall.callNoReturn(
                    // Use a dedicated relayer for ERC-6492 signatures so that the caller
                    // can't be arbitrarily used if it has special permissions on a target contract
                    RelayedCall.getRelayer(ERC6492_SUFFIX),
                    abi.encodePacked(factoryOrPrepareTo, factoryOrPrepareCalldata)
                )
            ) {
                isValid = isValidERC1271SignatureNow(signer, hash, signature);
            } // Do not attempt validation if the call failed
            break;
        }

        // Fallback to ECDSA signature validation
        if (!hasCode && !isValid) {
            (address recovered, ECDSA.RecoverError err, ) = ECDSA.tryRecover(hash, signature);
            isValid = err == ECDSA.RecoverError.NoError && recovered == signer;
        }

        return isValid;
    }

    /**
     * @dev Verifies a signature for a given ERC-7913 signer and hash.
     *
     * The signer is a `bytes` object that is the concatenation of an address and optionally a key:
     * `verifier || key`. A signer must be at least 20 bytes long.
     *
     * Verification is done as follows:
     *
     * * If `signer.length < 20`: verification fails
     * * If `signer.length == 20`: verification is done using {isValidSignatureNow}
     * * Otherwise: verification is done using {IERC7913SignatureVerifier}
     *
     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus
     * change through time. It could return true at block N and false at block N+1 (or the opposite).
     */
    function isValidSignatureNow(
        bytes memory signer,
        bytes32 hash,
        bytes memory signature
    ) internal view returns (bool) {
        if (signer.length < 20) {
            return false;
        } else if (signer.length == 20) {
            return isValidSignatureNow(address(bytes20(signer)), hash, signature);
        } else {
            (bool success, bytes memory result) = address(bytes20(signer)).staticcall(
                abi.encodeCall(IERC7913SignatureVerifier.verify, (signer.slice(20), hash, signature))
            );
            return (success &&
                result.length >= 32 &&
                abi.decode(result, (bytes32)) == bytes32(IERC7913SignatureVerifier.verify.selector));
        }
    }

    /**
     * @dev Verifies multiple ERC-7913 `signatures` for a given `hash` using a set of `signers`.
     * Returns `false` if the number of signers and signatures is not the same.
     *
     * The signers should be ordered by their `keccak256` hash to ensure efficient duplication check. Unordered
     * signers are supported, but the uniqueness check will be more expensive.
     *
     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus
     * change through time. It could return true at block N and false at block N+1 (or the opposite).
     */
    function areValidSignaturesNow(
        bytes32 hash,
        bytes[] memory signers,
        bytes[] memory signatures
    ) internal view returns (bool) {
        if (signers.length != signatures.length) return false;

        bytes32 lastId = bytes32(0);

        for (uint256 i = 0; i < signers.length; ++i) {
            bytes memory signer = signers[i];

            // If one of the signatures is invalid, reject the batch
            if (!isValidSignatureNow(signer, hash, signatures[i])) return false;

            bytes32 id = keccak256(signer);
            // If the current signer ID is greater than all previous IDs, then this is a new signer.
            if (lastId < id) {
                lastId = id;
            } else {
                // If this signer id is not greater than all the previous ones, verify that it is not a duplicate of a previous one
                // This loop is never executed if the signers are ordered by id.
                for (uint256 j = 0; j < i; ++j) {
                    if (id == keccak256(signers[j])) return false;
                }
            }
        }

        return true;
    }

    function _tryDecodeERC6492Signature(
        bytes memory signature
    )
        private
        pure
        returns (
            bool decodable,
            address factoryOrPrepareTo,
            bytes memory factoryOrPrepareCalldata,
            bytes memory innerSignature
        )
    {
        // Minimum length of a valid ERC-6492 signature is 160 bytes
        // address(32) + factoryOrPrepareCalldataOffset(32) + innerSignatureOffset(32) + factoryOrPrepareCalldataLength(32) + innerSignatureLength(32)
        if (signature.length < 0xa0) return (false, address(0), bytes(""), bytes(""));

        uint256 factoryOrPrepareCalldataOffset;
        uint256 innerSignatureOffset;
        bytes32 ptr;
        assembly ("memory-safe") {
            ptr := add(signature, 0x20)
            factoryOrPrepareTo := mload(ptr)
            factoryOrPrepareCalldataOffset := mload(add(ptr, 0x20))
            innerSignatureOffset := mload(add(ptr, 0x40))
        }
        if (
            factoryOrPrepareCalldataOffset < 0x60 ||
            factoryOrPrepareCalldataOffset > signature.length ||
            innerSignatureOffset < 0x80 ||
            innerSignatureOffset > signature.length
        ) {
            // Validate bounds
            return (false, address(0), bytes(""), bytes(""));
        }

        uint256 factoryOrPrepareCalldataLength;
        uint256 innerSignatureLength;
        assembly ("memory-safe") {
            factoryOrPrepareCalldataLength := mload(add(ptr, factoryOrPrepareCalldataOffset))
            innerSignatureLength := mload(add(ptr, innerSignatureOffset))
        }
        if (
            factoryOrPrepareCalldataOffset + factoryOrPrepareCalldataLength > signature.length - 32 ||
            innerSignatureOffset + innerSignatureLength > signature.length - 32
        ) {
            // Validate bounds
            return (false, address(0), bytes(""), bytes(""));
        }

        return (
            true,
            factoryOrPrepareTo,
            signature.slice(
                factoryOrPrepareCalldataOffset,
                factoryOrPrepareCalldataOffset + factoryOrPrepareCalldataLength
            ),
            signature.splice(innerSignatureOffset, innerSignatureOffset + innerSignatureLength)
        );
    }

    function _tryDecodeERC6492SignatureCalldata(
        bytes calldata signature
    )
        private
        pure
        returns (
            bool decodable,
            address factoryOrPrepareTo,
            bytes calldata factoryOrPrepareCalldata,
            bytes calldata innerSignature
        )
    {
        // Minimum length of a valid ERC-6492 signature is 160 bytes
        // address(32) + factoryOrPrepareCalldataOffset(32) + innerSignatureOffset(32) + factoryOrPrepareCalldataLength(32) + innerSignatureLength(32)
        if (signature.length < 0xa0) return (false, address(0), Calldata.emptyBytes(), Calldata.emptyBytes());

        factoryOrPrepareTo = address(bytes20(signature[12:0x20]));
        uint256 factoryOrPrepareCalldataOffset = uint256(bytes32(signature[0x20:0x40]));
        uint256 innerSignatureOffset = uint256(bytes32(signature[0x40:0x60]));
        if (
            factoryOrPrepareCalldataOffset < 0x60 ||
            factoryOrPrepareCalldataOffset > signature.length ||
            innerSignatureOffset < 0x80 ||
            innerSignatureOffset > signature.length
        ) {
            // Validate bounds
            return (false, address(0), Calldata.emptyBytes(), Calldata.emptyBytes());
        }

        uint256 factoryOrPrepareCalldataLength = uint256(
            bytes32(signature[factoryOrPrepareCalldataOffset:factoryOrPrepareCalldataOffset + 32])
        );
        uint256 innerSignatureLength = uint256(bytes32(signature[innerSignatureOffset:innerSignatureOffset + 32]));
        if (
            factoryOrPrepareCalldataOffset + factoryOrPrepareCalldataLength > signature.length ||
            innerSignatureOffset + innerSignatureLength > signature.length
        ) {
            // Validate bounds
            return (false, address(0), Calldata.emptyBytes(), Calldata.emptyBytes());
        }

        return (
            true,
            factoryOrPrepareTo,
            signature[factoryOrPrepareCalldataOffset:factoryOrPrepareCalldataOffset + factoryOrPrepareCalldataLength],
            signature[innerSignatureOffset:innerSignatureOffset + innerSignatureLength]
        );
    }
}
