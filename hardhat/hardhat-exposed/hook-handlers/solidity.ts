import path from 'path';
import micromatch from 'micromatch';

import type { SolcConfig } from 'hardhat/types/config';
import type { SolidityHooks, HookContext } from 'hardhat/types/hooks';
import type {
  RunCompilationJobResult,
  CompilerInput,
  CompilerOutput,
  CompilerOutputError,
} from 'hardhat/types/solidity';

import type { Artifact } from 'hardhat/types/artifacts';
import { remove, writeJsonFile, writeUtf8File } from '@nomicfoundation/hardhat-utils/fs';
import { getPrefixedHexString } from '@nomicfoundation/hardhat-utils/hex';

import type {} from '../type-extensions';

import { getExposed, writeExposed } from '../core';

export default async (): Promise<Partial<SolidityHooks>> => ({
  async invokeSolc(
    context: HookContext,
    compiler: RunCompilationJobResult['compiler'],
    solcInput: CompilerInput,
    solcConfig: SolcConfig,
    next: (
      nextContext: HookContext,
      nextCompiler: RunCompilationJobResult['compiler'],
      nextSolcInput: CompilerInput,
      nextSolcConfig: SolcConfig,
    ) => Promise<CompilerOutput>,
  ): Promise<CompilerOutput> {
    // Precompilation
    const output: CompilerOutput = await next(context, compiler, solcInput, {
      ...solcConfig,
      settings: {
        ...solcConfig.settings,
        optimizer: { enabled: false },
        outputSelection: { '*': { '': ['ast'] } },
      },
    });

    // If precompilation succeeded, generate exposed files
    if (!output.errors?.some((e: CompilerOutputError) => e.severity === 'error')) {
      // Determine which files to include
      const include = (sourceName: string): boolean =>
        sourceName.startsWith('project/') &&
        context.config.exposed.include.some((p: string) =>
          micromatch.isMatch(path.relative('project/', sourceName), p),
        ) &&
        !context.config.exposed.exclude.some((p: string) =>
          micromatch.isMatch(path.relative('project/', sourceName), p),
        );

      // Generate exposed files
      const exposed = getExposed(output, include, context.config);

      // Write exposed files to disk and add them to the compilation input
      await writeExposed(exposed);
      for (const [fsPath, content] of exposed) {
        const relativePath = path.join('project', path.relative(context.config.paths.root, fsPath));
        solcInput.sources[relativePath] = { content };
      }

      // Full compilation
      const fullOutput = await next(context, compiler, solcInput, solcConfig);

      // #############################################################################################################
      // #                                 Write artifacts for exposed files - Begin                                 #
      // #############################################################################################################
      // NOTE: this should ideally be handled by hardhat. It currently does NOT work, because the artifacts produced are erased automatically for an unknown reason.
      const artifactsDirectory = await context.solidity.getArtifactsDirectory('contracts');
      for (const fsPath of exposed.keys()) {
        const relativePath = path.relative(context.config.paths.root, fsPath);
        const projectPath = path.join('project', relativePath);
        const fileFolder = path.join(artifactsDirectory, relativePath);

        await remove(fileFolder);

        const artifacts: Artifact[] = [];
        for (const [contractName, contract] of Object.entries(fullOutput.contracts?.[projectPath] ?? {})) {
          const evmBytecode = contract.evm?.bytecode;
          const bytecode: string = evmBytecode?.object !== undefined ? getPrefixedHexString(evmBytecode.object) : '';
          const evmDeployedBytecode = contract.evm?.deployedBytecode;
          const deployedBytecode: string =
            evmDeployedBytecode?.object !== undefined ? getPrefixedHexString(evmDeployedBytecode.object) : '';
          const linkReferences = evmBytecode?.linkReferences ?? {};
          const deployedLinkReferences = evmDeployedBytecode?.linkReferences ?? {};
          const immutableReferences = evmDeployedBytecode?.immutableReferences ?? {};

          const artifact: Artifact = {
            _format: 'hh3-artifact-1',
            contractName,
            sourceName: relativePath,
            abi: contract.abi,
            bytecode,
            deployedBytecode,
            linkReferences,
            deployedLinkReferences,
            immutableReferences,
            inputSourceName: projectPath,
            buildInfoId: '',
          };
          artifacts.push(artifact);

          await writeJsonFile(path.join(fileFolder, `${contractName}.json`), artifact);
        }

        if (artifacts.length === 0) continue;

        const artifactsDeclarationFile = `\
// This file was autogenerated by Hardhat, do not edit it.
// prettier-ignore
// tslint:disable
// eslint-disable
// biome-ignore format: see above

${artifacts
  .map(
    artifact => `export interface ${artifact.contractName}$Type {
  ${Object.entries(artifact)
    .map(([name, value]) => `readonly ${name}: ${JSON.stringify(value)};`)
    .join('\n  ')}
};`,
  )
  .join('\n\n')}

import "hardhat/types/artifacts";
declare module "hardhat/types/artifacts" {
  interface ArtifactMap {
    ${artifacts.map(artifact => `["${artifact.contractName}"]: ${artifact.contractName}$Type`).join('\n    ')};
    ${artifacts.map(artifact => `["${artifact.sourceName}:${artifact.contractName}"]: ${artifact.contractName}$Type`).join('\n    ')};
  }
}`;

        await writeUtf8File(path.join(fileFolder, 'artifacts.d.ts'), artifactsDeclarationFile);
      }
      // #############################################################################################################
      // #                                  Write artifacts for exposed files - End                                  #
      // #############################################################################################################

      return fullOutput;
    } else {
      // Full compilation
      return await next(context, compiler, solcInput, solcConfig);
    }
  },
});
